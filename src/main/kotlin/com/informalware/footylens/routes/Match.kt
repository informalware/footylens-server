package com.informalware.footylens.routes

import com.informalware.footylens.data.*
import com.informalware.footylens.data.Match
import com.informalware.footylens.data.mocks.getMatch
import com.informalware.footylens.plugins.matches
import io.ktor.http.*
import io.ktor.server.application.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import org.ktorm.database.Database
import org.ktorm.dsl.*
import org.ktorm.entity.filter
import org.ktorm.entity.filterColumns
import org.ktorm.entity.find
import org.ktorm.entity.map

/**
 * Define as rotas de GET para as partidas
 * */
fun Application.matchGetRoutes() {
    routing {
        // Obtém dados da partida
        get("/match/{id}") {
            val database = Database.connect("postgres://localhost:5432")

            call.parameters["id"]?.let {id ->
                val query = database.matches.find { Matches.id eq (id.toInt()) }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered match"))
                } else {
                    val req = call.receive<Map<String, List<String>>>()
                    val match = (query as Match)

                    call.respond(Match)
                }
            }
        }
        // Obtém reviews de uma partida
        get("/match/{id}/reviews") {
            val database = Database.connect("postgres://localhost:5432")

            call.parameters["id"]?.let {id ->
                val query = database.matches.find { Matches.id eq (id.toInt()) }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered match"))
                } else {
                    val reviews = database.matches
                        .filter { Matches.id eq id.toInt() }
                        .map { it.id }

                    call.respond(mapOf("reviews" to reviews))
                }
            }
        }
    }
}

/**
 * Define as rotas de POST para as partidas
 * */
fun Application.matchPostRoutes() {
    routing {
        // Registra uma nova partida
        post("/match") {
            val database = Database.connect("postgres://localhost:5432")

            val req = call.receive<MatchRegistryRequest>()

            database.insert(Matches) {
                set(it.home, req.home)
                set(it.away, req.away)
                set(it.home_scoreboard, req.scoreboard.first)
                set(it.away_scoreboard, req.scoreboard.second)
            }

            call.respond(HttpStatusCode.Created, mapOf("ok" to true))
        }
    }
}