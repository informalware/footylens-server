package com.informalware.footylens.routes

import com.informalware.footylens.data.Matches
import com.informalware.footylens.data.Match
import com.informalware.footylens.data.Events
import com.informalware.footylens.data.MatchRegistryRequest
import com.informalware.footylens.plugins.validateMatchById
import com.informalware.footylens.plugins.connectFooty
import com.informalware.footylens.plugins.matches
import com.informalware.footylens.plugins.events
import io.ktor.http.*
import io.ktor.server.application.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import org.ktorm.database.Database
import org.ktorm.dsl.*
import org.ktorm.entity.*

/**
 * Define as rotas de GET para as partidas
 * */
fun Application.matchGetRoutes() {
    routing {
        // Obtém uma série de partidas
        get("/matches") {
            val database = connectFooty()

            when (val reqs = call.request.queryParameters["matches"]) {
                null -> call.respond(HttpStatusCode.BadRequest, mapOf("error" to "Missing `matches` field with a list of requested matches"))
                else -> {
                    val ids = reqs.split(",").map { it.toInt() }
                    val invalid = ids.filter { !database.validateMatchById(it) }

                    if (invalid.isNotEmpty()) {
                        call.respond(HttpStatusCode.NotFound, mapOf("error" to "Matches not found: $invalid"))
                    } else {
                        val matches = database.matches.filter { Matches.id inList ids }.toList()
                        call.respond(mapOf("matches" to matches))
                    }
                }
            }
        }
        // Obtém dados da partida
        get("/matches/{id}") {
            val database = connectFooty()
            call.parameters["id"]?.let {id ->
                val query = database.matches.find { Matches.id eq (id.toInt()) }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered match"))
                } else {
                    val req = call.receive<Map<String, List<String>>>()
                    val match = (query as Match)

                    call.respond(match)
                }
            }
        }
        // Obtém mais detalhes de uma partida
        get("/matches/{id}/details") {
            val database = connectFooty()
            call.parameters["id"]?.let {id ->
                val query = database.matches.find { Matches.id eq (id.toInt()) }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered match"))
                } else {
                    val events = database.events
                        .filter { Events.matchId eq id.toInt() }
                        .map { it.id }

                    call.respond(mapOf("events" to events))
                }
            }
        }
        // Obtém reviews de uma partida
        get("/matches/{id}/reviews") {
            val database = connectFooty()
            call.parameters["id"]?.let {id ->
                val query = database.matches.find { Matches.id eq (id.toInt()) }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered match"))
                } else {
                    val reviews = database.matches
                        .filter { Matches.id eq id.toInt() }
                        .map { it.id }

                    call.respond(mapOf("reviews" to reviews))
                }
            }
        }
    }
}

/**
 * Define as rotas de POST para as partidas
 * */
fun Application.matchPostRoutes() {
    routing {
        // Registra uma nova partida
        post("/matches") {
            val database = connectFooty()

            val req = call.receive<MatchRegistryRequest>()

            database.insert(Matches) {
                set(it.home, req.home)
                set(it.away, req.away)
                set(it.h_scoreboard, req.scoreboard.first)
                set(it.v_scoreboard, req.scoreboard.second)
            }

            call.respond(HttpStatusCode.Created, mapOf("ok" to true))
        }
    }
}