package com.informalware.footylens.routes

import com.informalware.footylens.data.*
import com.informalware.footylens.plugins.*
import io.ktor.http.*
import io.ktor.server.application.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import org.ktorm.dsl.*
import org.ktorm.entity.*

fun Application.userGetRoutes() {
    routing {
        get("/users") {
            val database = connectFooty()

            when (val reqs = call.request.queryParameters["users"]) {
                null -> call.respond(HttpStatusCode.BadRequest, mapOf("error" to "Missing `users` field with a list of requested teams"))
                else -> {
                    val ids = reqs.split(",").map { it.toInt() }
                    val invalid = ids.filter { !database.validateUserById(it) }

                    if (invalid.isNotEmpty()) {
                        call.respond(HttpStatusCode.NotFound, mapOf("error" to "Users not found: $invalid"))
                    } else {
                        val users = database.users.filter { Users.id inList ids }.toList()
                        call.respond(mapOf("users" to users))
                    }
                }
            }
        }
        // Obtém os dados de um usuário pelo seu username
        get("/users/@{username}") {
            val database = connectFooty()

            call.parameters["username"]?.let {username ->
                val user = database.users.find { Users.username eq username }

                if (user == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "@$username is not a registered user"))
                } else {
                    call.respond(user)
                }
            }
        }
        // Obtém dados de um usuário pela sua id
        get("/users/{id}") {
            val database = connectFooty()

            call.parameters["id"]?.let {id ->
                val user = database.users.find { Users.id eq (id.toInt()) }

                if (user == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered user"))
                } else {
                    call.respond(user)
                }
            }
        }

        get("/users/{id}/username") {
            val database = connectFooty()

            call.parameters["id"]?.let {id ->
                val user = database.users.find { Users.id eq id.toInt() }

                if (user == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered user"))
                } else {
                    call.respond(mapOf("username" to user.username))
                }
            }
        }
        // Obtém a lista de seguidores de um usuário
        get("/users/{id}/followers") {
            val database = connectFooty()

            call.parameters["id"]?.let {id ->
                if (!database.validateUserById(id.toInt())) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered user"))
                } else {
                    val follows = database.follows
                        .filter { Follows.user_id eq id.toInt() }
                        .map { it.follower_id }

                    call.respond(mapOf("followers" to follows))
                }
            }
        }
        // Obtém a lista de seguidos por um usuário
        get("/users/{id}/follows") {
            val database = connectFooty()

            call.parameters["id"]?.let {id ->
                if (!database.validateUserById(id.toInt())) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered user"))
                } else {
                    val follows = database.follows
                        .filter { Follows.follower_id eq id.toInt() }
                        .map { it.user_id }

                    call.respond(mapOf("follows" to follows))
                }
            }
        }
        // Obtém a lista de times seguidos por um usuário
        get("/users/{id}/teams") {
            val database = connectFooty()

            call.parameters["id"]?.let {id ->
                if (!database.validateUserById(id.toInt())) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered user"))
                } else {
                    val follows = database.teamsfollows
                        .filter { TeamsFollows.follower_id eq id.toInt() }
                        .map { it.team_id }

                    call.respond(mapOf("follows" to follows))
                }
            }
        }
        // Obtém a lista de reviews feitas por um usuário
        get("/users/{id}/reviews") {
            val database = connectFooty()

            call.parameters["id"]?.let {id ->
                if (!database.validateUserById(id.toInt())) {
                    call.respond(HttpStatusCode.NotFound, "$id is not a registered user")
                } else {
                    val reviews = database.reviews.filter { Reviews.userId eq id.toInt() }.map { it.id }
                    call.respond(mapOf("reviews" to reviews))
                }
            }
        }
        // Obtém a lista de comentários feitas por um usuário
        get("/users/{id}/commentaries") {
            val database = connectFooty()

            call.parameters["id"]?.let {id ->
                if (!database.validateUserById(id.toInt())) {
                    call.respond(HttpStatusCode.NotFound, "$id is not a registered user")
                } else {
                    val commentaries = database.commentaries.filter { Commentaries.userId eq id.toInt() }.map { it.id }
                    call.respond(mapOf("commentaries" to commentaries))
                }
            }
        }
    }
}

fun Application.userPostRoutes() {
    routing {
        // Registra um novo usuário
        post("/users") {
            val database = connectFooty()
            val form = call.receive<UserRegistryRequest>()

            if (database.validateUserByUsername(form.username)) {
                call.respond(HttpStatusCode.Conflict, "User with username ${form.username} already exists")
            } else {
                database.insert(Users) {
                    set(it.username, form.username)
                    set(it.password, form.password)
                    set(it.bio, "Hello I'm using Footylens")
                    set(it.display, form.display)
                    set(it.email, form.email)
                }

                call.respond(HttpStatusCode.Created, mapOf("ok" to true))
            }
        }

        post ("/users/{id}/teams") {
            val database = connectFooty()
            val id = (call.parameters["id"] ?: "0").toInt()
            when (val teamId = call.receive<Map<String, Int>>()["team_id"]) {
                null -> call.respond(HttpStatusCode.BadRequest, "Missing field team_id")
                else -> {
                    database.insert(TeamsFollows) {
                        set(it.follower_id, id)
                        set(it.team_id, teamId)
                    }

                    call.respond(HttpStatusCode.OK)
                }
            }
        }

        post ("/users/{id}/follows") {
            val database = connectFooty()
            val id = call.parameters["id"]?.toInt()!!

            when (val followsId = call.receive<Map<String, Int>>()["follows_id"]) {
                null -> call.respond(HttpStatusCode.BadRequest, "Missing field team_id")
                else -> {
                    database.insert(Follows) {
                        set(it.follower_id, id) // A ordem está correta
                        set(it.user_id, followsId)
                    }

                    call.respond(HttpStatusCode.OK)
                }
            }
        }
    }
}

fun Application.userDeleteRoutes() {
    routing {
        delete("/users/{id}/teams/{team_id}") {
            val database = connectFooty()
            val id = call.parameters["id"]?.toInt()!!
            val teamId = call.parameters["team_id"]?.toInt()!!

            database.delete(TeamsFollows) {
                (it.follower_id eq id) and (it.team_id eq teamId)
            }

            call.respond(HttpStatusCode.OK)
        }

        delete("/users/{id}/users/{follows_id}") {
            val database = connectFooty()
            val id = call.parameters["id"]?.toInt()!!
            val followsId = call.parameters["follows_id"]?.toInt()!!

            database.delete(Follows) {
                (it.follower_id eq id) and (it.user_id eq followsId)
            }

            call.respond(HttpStatusCode.OK)
        }
    }
}

fun Application.userUpdateRoutes() {
    routing {
        patch("/users/{id}") {
            val database = connectFooty()
            val id = call.parameters["id"]?.toInt()!!
            val form = call.receive<UserUpdateRequest>()

            if (!database.validateUserById(id)) {
                call.respond(HttpStatusCode.NotFound, mapOf("error" to "User $id not found"))
            } else {
                database.update(Users) {
                    if(form.display.isNotBlank()) set(it.display, form.display)
                    if(form.bio.isNotBlank()) set(it.bio, form.bio)
                    if(form.email.isNotBlank()) set(it.email, form.email)
                    where {
                        it.id eq id
                    }
                }

                call.respond(HttpStatusCode.OK)
            }
        }
    }
}
