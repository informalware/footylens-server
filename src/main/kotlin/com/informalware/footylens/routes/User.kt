package com.informalware.footylens.routes

import com.informalware.footylens.data.*
import com.informalware.footylens.data.mocks.getUserFollowedBy
import com.informalware.footylens.data.mocks.getUserById
import com.informalware.footylens.data.mocks.registerUser
import com.informalware.footylens.plugins.follows
import com.informalware.footylens.plugins.users
import io.ktor.http.*
import io.ktor.server.application.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import org.ktorm.database.Database
import org.ktorm.dsl.*
import org.ktorm.entity.filter
import org.ktorm.entity.filterColumns
import org.ktorm.entity.find
import org.ktorm.entity.map

fun Application.userGetRoutes() {
    routing {
        // Obtém os dados de um usuário pelo seu username
        get("/users/@{username}") {
            val database = Database.connect("jdbc:postgresql://localhost:5432/footylens", "org.postgresql.Driver", "footy", "senhasenha")

            call.parameters["username"]?.let {username ->
                val query = database.users.find { Users.username eq username }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "@$username is not a registered user"))
                } else {
                    val req = call.receive<Map<String, List<String>>>()
                    val user = (query as User)


                    call.respond(user)
                }
            }
        }
        // Obtém dados de um usuário pela sua id
        get("/users/{id}") {
            val database = Database.connect("jdbc:postgresql://localhost:5432/footylens", "org.postgresql.Driver", "footy", "senhasenha")

            call.parameters["id"]?.let {id ->
                val query = database.users.find { Users.id eq (id.toInt()) }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered user"))
                } else {
                    val req = call.receive<Map<String, List<String>>>()
                    val user = (query as User)


                    call.respond(user)
                }
            }
        }

        get("/users/{id}/username") {
            val database = Database.connect("jdbc:postgresql://localhost:5432/footylens", "org.postgresql.Driver", "footy", "senhasenha")
            call.parameters["id"]?.let {id ->
                val query = database.users.find { Users.id eq id.toInt() }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered user"))
                } else {
                    call.respond(mapOf("username" to query.username))
                }
            }
        }
        // Obtém a lista de seguidores de um usuário
        get("/users/{id}/followers") {
            val database = Database.connect("jdbc:postgresql://localhost:5432/footylens", "org.postgresql.Driver", "footy", "senhasenha")

            call.parameters["id"]?.let {id ->
                val query = database.users.find { Users.id eq id.toInt() }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered user"))
                } else {
                    val follows = database.follows
                        .filter { Follows.user_id eq id.toInt() }
                        .map { it.follower_id }

                    call.respond(mapOf("followers" to follows))
                }
            }
        }
        // Obtém a lista de seguidos por um usuário
        get("/users/{id}/follows") {
            val database = Database.connect("jdbc:postgresql://localhost:5432/footylens", "org.postgresql.Driver", "footy", "senhasenha")

            call.parameters["id"]?.let {id ->
                val query = database.users.find { Users.id eq id.toInt() }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered user"))
                } else {
                    val follows = database.follows
                        .filter { Follows.follower_id eq id.toInt() }
                        .map { it.user_id }

                    call.respond(mapOf("follows" to follows))
                }
            }
        }
        // Obtém a lista de reviews feitas por um usuário
        get("/users/{id}/reviews") {
            val database = Database.connect("jdbc:postgresql://localhost:5432/footylens", "org.postgresql.Driver", "footy", "senhasenha")

            call.parameters["id"]?.let {id ->
                // TODO: Implement reviews tables
                call.respond(HttpStatusCode.NotImplemented , "This endpoint is not yet implemented")
            }
        }
        // Obtém a lista de comentários feitas por um usuário
        get("/users/{id}/commentaries") {
            val database = Database.connect("jdbc:postgresql://localhost:5432/footylens", "org.postgresql.Driver", "footy", "senhasenha")

            call.parameters["id"]?.let {id ->
                call.respond(HttpStatusCode.NotImplemented , "This endpoint is not yet implemented")
            }
        }
    }
}

fun Application.userPostRoutes() {
    routing {
        // Registra um novo usuário
        post("/users") {
            val database = Database.connect("jdbc:postgresql://localhost:5432/footylens", "org.postgresql.Driver", "footy", "senhasenha")
            val form = call.receive<UserRegistryRequest>()

            if (database.users.find { it.username eq form.username } != null) {
                call.respond(HttpStatusCode.Conflict, "User with username ${form.username} already exists")
            } else {
                database.insert(Users) {
                    set(it.username, form.username)
                    set(it.password, form.password)
                    set(it.bio, "Hello I'm using Footylens")
                    set(it.display, form.display)
                    set(it.email, form.email)
                }

                call.respond(HttpStatusCode.Created, mapOf("ok" to true))
            }
        }
    }
}