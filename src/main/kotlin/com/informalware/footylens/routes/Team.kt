package com.informalware.footylens.routes

import com.informalware.footylens.data.Team
import com.informalware.footylens.data.TeamRegistryRequest
import com.informalware.footylens.data.Teams
import com.informalware.footylens.data.TeamsFollows
import com.informalware.footylens.data.Matches
import com.informalware.footylens.plugins.connectFooty
import com.informalware.footylens.plugins.validateTeamById
import com.informalware.footylens.plugins.validateTeamByName
import com.informalware.footylens.plugins.teams
import com.informalware.footylens.plugins.teamsfollows
import com.informalware.footylens.plugins.matches
import io.ktor.http.*
import io.ktor.server.application.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import org.ktorm.dsl.*
import org.ktorm.entity.filter
import org.ktorm.entity.find
import org.ktorm.entity.map
import org.ktorm.entity.toList

/**
 * Define as rotas de GET para os times
 */
fun Application.teamGetRoutes(testing: Boolean = false) {
    routing {
        // Obtém uma série de times
        get("/teams") {
            val database = connectFooty(testing)

            when (val reqs = call.request.queryParameters["teams"]) {
                null -> call.respond(HttpStatusCode.BadRequest, mapOf("error" to "Missing `teams` field with a list of requested teams"))
                else -> {
                    val ids = reqs.split(",").map { it.toInt() }
                    val invalid = ids.filter { !database.validateTeamById(it) }

                    if (invalid.isNotEmpty()) {
                        call.respond(HttpStatusCode.NotFound, mapOf("error" to "Teams not found: $invalid"))
                    } else {
                        val teams = database.teams.filter { Teams.id inList ids }.toList()
                        call.respond(mapOf("teams" to teams))
                    }
                }
            }
        }
        // Obtém dados de um time pelo seu id
        get("/teams/{id}") {
            val database = connectFooty(testing)
            call.parameters["id"]?.let {id ->
                val query = database.teams.find { Teams.id eq id.toInt() }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered team"))
                } else {
                    val team = (query as Team)

                    call.respond(team)
                }
            }
        }
        // Obtém dados de um time pelo seu nome
        get("/teams/{name}") {
            val database = connectFooty(testing)
            call.parameters["name"]?.let {name ->
                val query = database.teams.find { Teams.name eq name }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$name is not a registered team"))
                } else {
                    val team = (query as Team)

                    call.respond(team)
                }
            }
        }
        // Obtém a lista de seguidores de um time
        get("/teams/{id}/followers") {
            val database = connectFooty(testing)
            call.parameters["id"]?.let {id ->
                if (!database.validateTeamById(id.toInt())) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered team"))
                } else {
                    val follows = database.teamsfollows
                        .filter { TeamsFollows.team_id eq id.toInt() }
                        .map { it.follower_id }

                    call.respond(mapOf("followers" to follows))
                }
            }
        }
        // Obtém a lista de partidas de um time
        get("/teams/{id}/matches") {
            val database = connectFooty(testing)
            call.parameters["id"]?.let { id ->
                if (!database.validateTeamById(id.toInt())) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered team"))
                } else {
                    val matches = database.matches
                        .filter { (Matches.home eq id.toInt()) or (Matches.away eq id.toInt()) }
                        .map { it.id }

                    call.respond(mapOf("matches" to matches))
                }
            }
        }
    }
}

/**
 * Registra um novo time no banco de dados
 */
fun Application.teamPostRoutes(testing: Boolean = false) {
    routing {
        post("/teams") {
            val database = connectFooty(testing)
            val form = call.receive<TeamRegistryRequest>()

            if(database.validateTeamByName(form.name)) {
                call.respond(HttpStatusCode.Conflict, mapOf("error" to "Team ${form.name} already exists"))
            } else {
                database.insert(Teams) {
                    set(it.name, form.name)
                    set(it.league, form.league)
                }
            }

            call.respond(HttpStatusCode.Created, mapOf("ok" to true))
        }
    }
}