package com.informalware.footylens.routes

import com.informalware.footylens.data.*
import com.informalware.footylens.plugins.teams
import com.informalware.footylens.plugins.teamsfollows
import com.informalware.footylens.plugins.matches
import io.ktor.http.*
import io.ktor.server.application.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import org.ktorm.database.Database
import org.ktorm.dsl.*
import org.ktorm.entity.filter
import org.ktorm.entity.filterColumns
import org.ktorm.entity.find
import org.ktorm.entity.map

/**
 * Define as rotas de GET para os times
 */
fun Application.teamGetRoutes() {
    routing {
        // Obtém dados de um time
        get("/team/{id}") {
            call.parameters["id"]?.let {id ->
                val database = Database.connect("postgres://localhost:5432")

                val query = database.teams.find { Teams.id eq id.toInt() }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered team"))
                } else {
                    val team = (query as Team)

                    call.respond(team)
                }
            }
        }
        // Obtém a lista de seguidores de um time
        get("/team/{id}/followers") {
            call.parameters["id"]?.let {id ->
                val database = Database.connect("postgres://localhost:5432")

                val query = database.teams.find { Teams.id eq id.toInt() }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered team"))
                } else {
                    val follows = database.teamsfollows
                        .filter { TeamsFollows.team_id eq id.toInt() }
                        .map { it.follower_id }

                    call.respond(mapOf("followers" to follows))
                }
            }
        }
        // Obtém a lista de partidas de um time
        get("/team/{id}/matches") {
            call.parameters["id"]?.let { id ->
                val database = Database.connect("postgres://localhost:5432")

                val query = database.teams.find { Teams.id eq id.toInt() }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a registered team"))
                } else {
                    val team = (query as Team)

                    val matches = database.matches
                        .filter { (Matches.home eq team.id) or (Matches.away eq team.id) }
                        .map { it }

                    call.respond(mapOf("matches" to matches))
                }
            }
        }
    }
}

/**
 * Registra um novo time no banco de dados
 */
fun Application.teamPostRoutes() {
    routing {
        post("/team") {
            val database = Database.connect("postgres://localhost:5432")
            val form = call.receive<TeamRegistryRequest>()

            if(database.teams.find { it.name eq form.name } != null) {
                call.respond(HttpStatusCode.Conflict, mapOf("error" to "Team ${form.name} already exists"))
            } else {
                database.insert(Teams) {
                    set(it.name, form.name)
                    set(it.league, form.league)
                }
            }

            call.respond(HttpStatusCode.Created, mapOf("ok" to true))
        }
    }
}