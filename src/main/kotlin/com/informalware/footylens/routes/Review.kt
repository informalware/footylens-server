package com.informalware.footylens.routes

import com.informalware.footylens.data.*
import com.informalware.footylens.plugins.*
import io.ktor.http.*
import io.ktor.server.application.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import org.ktorm.database.Database
import org.ktorm.dsl.eq
import org.ktorm.dsl.inList
import org.ktorm.dsl.insert
import org.ktorm.entity.filter
import org.ktorm.entity.find
import org.ktorm.entity.map
import org.ktorm.entity.toList
import java.time.LocalDateTime

fun Application.reviewGetRoutes() {
    routing {
        // Obtem uma série de reviews
        get("/reviews") {
            val database = connectFooty()

            when (val reqs = call.request.queryParameters["reviews"]) {
                null -> call.respond(HttpStatusCode.BadRequest, mapOf("error" to "Missing `reviews` field with a list of requested reviews"))
                else -> {
                    val ids = reqs.split(",").map { it.toInt() }
                    val invalid = ids.filter { !database.validateReviewById(it) }

                    if (invalid.isNotEmpty()) {
                        call.respond(HttpStatusCode.NotFound, mapOf("error" to "Reviews not found: $invalid"))
                    } else {
                        val reviews = database.reviews.filter { Reviews.id inList ids }.toList()
                        call.respond(mapOf("reviews" to reviews))
                    }
                }
            }
        }
        // Obtem uma review
        get("/reviews/{id}") {
            val database = connectFooty()

            call.parameters["id"]?.let {id ->
                val query = database.reviews.find { Reviews.id eq (id.toInt()) }

                if (query == null) {
                    call.respond(HttpStatusCode.NotFound, mapOf("error" to "$id is not a review"))
                } else {
                    val req = call.request.queryParameters["summarized"]
                    val review = (query as Review)

                    if (req != null) {
                        val len = req.toInt()

                        call.respond(review.summarize(len))
                    } else {
                        call.respond(review)
                    }
                }
            }
        }
        // Obtem a lista de comentários de uma review
        get("/reviews/{id}/commentaries") {
            val database = connectFooty()
            val id = call.parameters["id"]!!

            if (!database.validateUserById(id.toInt())) {
                call.respond(HttpStatusCode.NotFound, "$id is not a review")
            } else {
                val commentaries = database.commentaries.filter { Commentaries.reviewId eq id.toInt() }.map { it.id }
                call.respond(HttpStatusCode.OK, mapOf("commentaries" to commentaries))
            }
        }
    }
}

fun Application.reviewPostRoutes() {
    routing {
        post("/reviews") {
            val database = connectFooty()
            val review = call.receive<ReviewRegistryRequest>()

            // TODO: check if the match exists

            if (!database.validateUserById(review.userId)) {
                call.respond(HttpStatusCode.NotFound, mapOf("error" to "${review.userId} is not a registered user"))
            } else {
                database.insert(Reviews) {
                    set(it.userId, review.userId)
                    set(it.matchId, review.matchId)
                    set(it.review, review.review)
                    set(it.rating, review.rating)
                    set(it.creationDate, LocalDateTime.now())
                    set(it.lastModifiedDate, LocalDateTime.now())
                }

                call.respond(HttpStatusCode.Created, mapOf("ok" to true))
            }
        }
    }
}